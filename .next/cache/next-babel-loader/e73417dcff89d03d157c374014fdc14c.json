{"ast":null,"code":"import { useState, useEffect } from 'react';\nimport { debounce } from 'lodash';\n\n/**\n * @usage\n * import { useBreakpoint } from '@hooks/useBreakpoint';\n * const { xs, sm, md, lg, xl, xxl, smAndUp, lgAndDown } = useBreakpoint();\n * style={{ width: xs ? '100%' : '50%' }}\n * xs is a reactively changing boolean that evaluates to true if the current breakpoint is xs\n*/\n\n/**\n * @typedef {\"smAndDown\" | \"smAndUp\" | \"mdAndDown\" | \"mdAndUp\" | \"lgAndDown\" | \"lgAndUp\"} BreakpointHelper\n*/\n\n/**\n * @typedef {\"xs\" | \"sm\" | \"md\" | \"lg\" | \"xl\" | \"xxl\" | BreakpointHelper} Breakpoint\n*/\n\n/**\n * @type {Record<Breakpoint, number>}\n * @description enum for the different breakpoint sizes\n * @example BreakpointSize.xs === 576\n */\nexport const BreakpointSize = {\n  xs: 576,\n  sm: 768,\n  md: 992,\n  lg: 1200,\n  xl: 1440,\n  xxl: 9999\n};\n\n/**\n * @type {Record<Breakpoint, string>}\n * @description enum for the different breakpoints\n * @example Breakpoint.xs === 'xs'\n */\nexport const Breakpoint = {\n  // base props\n  xs: 'xs',\n  sm: 'sm',\n  md: 'md',\n  lg: 'lg',\n  xl: 'xl',\n  xxl: 'xxl',\n  // helper props\n  smAndDown: 'smAndDown',\n  smAndUp: 'smAndUp',\n  mdAndDown: 'mdAndDown',\n  mdAndUp: 'mdAndUp',\n  lgAndDown: 'lgAndDown',\n  lgAndUp: 'lgAndUp'\n};\n\n/**\n * @type {Record<BreakpointHelper, Breakpoint => boolean>}\n * @description maps helper props to their respective predicates\n */\nexport const breakpointHelpers = {\n  smAndDown: size => size === Breakpoint.xs || size === Breakpoint.sm,\n  smAndUp: size => size !== Breakpoint.xs,\n  mdAndDown: size => size === Breakpoint.xs || size === Breakpoint.sm || size === Breakpoint.md,\n  mdAndUp: size => size !== Breakpoint.xs && size !== Breakpoint.sm,\n  lgAndDown: size => size === Breakpoint.xl || size === Breakpoint.xxl,\n  lgAndUp: size => size !== Breakpoint.xl && size !== Breakpoint.xxl\n};\n\n/**\n * @param {number} width\n * @returns {Breakpoint}\n */\nconst resolveBreakpoint = width => {\n  const breakpoints = Object.entries(BreakpointSize);\n  const [breakpoint] = breakpoints.find(([_, value]) => width < value);\n  return breakpoint;\n};\n\n/**\n * @returns {Breakpoint}\n */\nexport const useBreakpoint = () => {\n  // for ssr\n  if (true) {\n    return Breakpoint.xxl;\n  }\n  const {\n    0: size,\n    1: setSize\n  } = useState(() => resolveBreakpoint(window.innerWidth));\n  const setBreakpoint = () => setSize(resolveBreakpoint(window.innerWidth));\n  useEffect(() => {\n    const calcInnerWidth = debounce(setBreakpoint, 200);\n    window.addEventListener('resize', calcInnerWidth);\n    return () => window.removeEventListener('resize', calcInnerWidth);\n  }, []);\n  return new Proxy(Breakpoint, {\n    get(target, prop) {\n      if (!(prop in target)) throw new Error(`Invalid breakpoint: ${prop}`);\n      return prop in breakpointHelpers ? breakpointHelpers[prop](size) : size === prop;\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"module"}