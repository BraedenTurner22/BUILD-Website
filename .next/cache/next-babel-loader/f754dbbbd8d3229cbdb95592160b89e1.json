{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/esm/slicedToArray\";\nimport { useState, useEffect } from 'react';\nimport { debounce } from 'lodash';\n\n/**\n * @usage\n * import { useBreakpoint } from '@hooks/useBreakpoint';\n * const { xs, sm, md, lg, xl, xxl, smAndUp, lgAndDown } = useBreakpoint();\n * style={{ width: xs ? '100%' : '50%' }}\n * xs is a reactively changing boolean that evaluates to true if the current breakpoint is xs\n*/\n\n/**\n * @typedef {\"smAndDown\" | \"smAndUp\" | \"mdAndDown\" | \"mdAndUp\" | \"lgAndDown\" | \"lgAndUp\"} BreakpointHelper\n*/\n\n/**\n * @typedef {\"xs\" | \"sm\" | \"md\" | \"lg\" | \"xl\" | \"xxl\" | BreakpointHelper} Breakpoint\n*/\n\n/**\n * @type {Record<Breakpoint, number>}\n * @description enum for the different breakpoint sizes\n * @example BreakpointSize.xs === 576\n */\nexport var BreakpointSize = {\n  xs: 576,\n  sm: 768,\n  md: 992,\n  lg: 1200,\n  xl: 1440,\n  xxl: 9999\n};\n\n/**\n * @type {Record<Breakpoint, string>}\n * @description enum for the different breakpoints\n * @example Breakpoint.xs === 'xs'\n */\nexport var Breakpoint = {\n  // base props\n  xs: 'xs',\n  sm: 'sm',\n  md: 'md',\n  lg: 'lg',\n  xl: 'xl',\n  xxl: 'xxl',\n  // helper props\n  smAndDown: 'smAndDown',\n  smAndUp: 'smAndUp',\n  mdAndDown: 'mdAndDown',\n  mdAndUp: 'mdAndUp',\n  lgAndDown: 'lgAndDown',\n  lgAndUp: 'lgAndUp'\n};\n\n/**\n * @type {Record<BreakpointHelper, Breakpoint => boolean>}\n * @description maps helper props to their respective predicates\n */\nexport var breakpointHelpers = {\n  smAndDown: function smAndDown(size) {\n    return size === Breakpoint.xs || size === Breakpoint.sm;\n  },\n  smAndUp: function smAndUp(size) {\n    return size !== Breakpoint.xs;\n  },\n  mdAndDown: function mdAndDown(size) {\n    return size === Breakpoint.xs || size === Breakpoint.sm || size === Breakpoint.md;\n  },\n  mdAndUp: function mdAndUp(size) {\n    return size !== Breakpoint.xs && size !== Breakpoint.sm;\n  },\n  lgAndDown: function lgAndDown(size) {\n    return size === Breakpoint.xl || size === Breakpoint.xxl;\n  },\n  lgAndUp: function lgAndUp(size) {\n    return size !== Breakpoint.xl && size !== Breakpoint.xxl;\n  }\n};\n\n/**\n * @param {number} width\n * @returns {Breakpoint}\n */\nvar resolveBreakpoint = function resolveBreakpoint(width) {\n  var breakpoints = Object.entries(BreakpointSize);\n  var _breakpoints$find = breakpoints.find(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        _ = _ref2[0],\n        value = _ref2[1];\n      return width < value;\n    }),\n    _breakpoints$find2 = _slicedToArray(_breakpoints$find, 1),\n    breakpoint = _breakpoints$find2[0];\n  return breakpoint;\n};\n\n/**\n * @returns {Breakpoint}\n */\nexport var useBreakpoint = function useBreakpoint() {\n  // for ssr\n  if (false) {\n    return Breakpoint.xxl;\n  }\n  var _useState = useState(function () {\n      return resolveBreakpoint(window.innerWidth);\n    }),\n    size = _useState[0],\n    setSize = _useState[1];\n  var setBreakpoint = function setBreakpoint() {\n    return setSize(resolveBreakpoint(window.innerWidth));\n  };\n  useEffect(function () {\n    var calcInnerWidth = debounce(setBreakpoint, 200);\n    window.addEventListener('resize', calcInnerWidth);\n    return function () {\n      return window.removeEventListener('resize', calcInnerWidth);\n    };\n  }, []);\n  return new Proxy(Breakpoint, {\n    get: function get(target, prop) {\n      if (!(prop in target)) throw new Error(\"Invalid breakpoint: \".concat(prop));\n      return prop in breakpointHelpers ? breakpointHelpers[prop](size) : size === prop;\n    }\n  });\n};","map":null,"metadata":{},"sourceType":"module"}